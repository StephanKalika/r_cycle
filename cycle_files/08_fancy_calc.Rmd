---
title: "[Заметки по R](http://bdemeshev.github.io/r_cycle/): R --- весёлый калькулятор"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output: html_document
lang: russian
---
Сначала загружаем пакет для строительства красивых графиков: 

```{r}
library(ggplot2)
```


R можно использовать как весёлый калькулятор:
```{r}
5 + 9
```


Что-нибудь более интересное:
```{r}
a <- factorial(4)
b <- 2^3
a + b
```

Признайся, шалунишка, ты всегда мечтал поделить на ноль?
```{r}
a <- 1 / 0
a
```

Что можно делать с бесконечностью?
```{r}
1 / (a - 9)
```

Возьмём арктангенс!
```{r}
atan(Inf)
```

Ба! Да это же $\pi/2$:
```{r}
pi / 2
```

Но с неопределенностью ничего не поделаешь: 
```{r}
0 / 0
```

NaN расшифровывается как «Not a Number». NaN отличается от NA («Not Available», пропущенные данные); точнее, всякое NaN --- NA, но не всякое NA --- NaN. Проверять, является ли что-либо NA или NaN, можно так: 
```{r}
is.na(0 / 0)

a <- NA
is.na(a)
is.nan(a)
```

  
### А теперь векторы

Вектор из чисел по порядку:
```{r}
a <- 3:10
a
```

Вектор из одинаковых чисел:
```{r}
b <- rep(777, times = 5)
b
```

Вектор из конкретных чисел:
```{r}
vect <- c(5, -4, 1)
```

Что можно делать с вектором?
```{r}
sum(vect)
```

Хотите среднее арифметическое?
```{r}
mean(vect)
```

### Генерация случайных величин

Хочу 300 случайных натуральных чисел от 1 до 5 с повторами! И побыстрее!
```{r}
h <- sample(1:5, 300, rep = TRUE)
```

Краткая информация о векторе $h$, начало вектора $h$ и конец вектора $h$:
```{r}
str(h)
head(h)
tail(h)
```

Хочу сгенирировать выборку из 500 значений случайной величины $X$ с вероятностями:

$X$   |  -2 | 3   | 7
------|-----|-----|-----
$P()$ | 0.1 | 0.2 | 0.7

Зададим вектор вектор возможных значений и вектор вероятностей:
```{r}
x.val <- c(-2, 3, 7)
x.pr <- c(0.1, 0.2, 0.7)
```

Получаем выборку из 500 значений:
```{r}
s <- sample(x.val, 500, rep = TRUE, x.pr)
str(s)
```

### Два простеньких графика

Простенькую гистограмму можно построить, например, с помощью функции `qplot` из пакета `ggplot2`:
```{r, warning=FALSE}
qplot(factor(s), xlab = "Значение", ylab = "Количество", main = "Гистограмма")
```

Ту же гистограммку можно построить с помощью функции `ggplot` из того же пакета, предварительно преобразовав s в необходимый для `ggplot` формат data frame:
```{r}
s_df <- data.frame(s)
ggplot(s_df) + geom_bar(aes(factor(s))) + labs(x = "Значение", y = "Количество", title = "Гистограмма")
```

И еще простенький график:
```{r, warning=FALSE}
x <- rnorm(500) # 500 нормальных величин со средним 0 и дисперсией 1
y <- rnorm(500) # 500 нормальных величин со средним 0 и дисперсией
qplot(x, y, main = "Точечки")
```

Или:
```{r}
xy_df <- data.frame(x = x, y = y)
ggplot(xy_df) + geom_point(aes(x, y)) + labs(title = "Точечки")
```

В зависимости от формата данных часто бывает удобно использовать и `qplot`, и `ggplot`.

### Отбор значений

Выберем из вектора $s$ значения больше $0$:
```{r}
b <- s[s > 0]
b
str(b)
```

Можно выбрать конкретные $s$, например с 6-го по 20-ое:
```{r}
s[6:20]
```

Хочу 5-ое, 7-ое и 13-ое!
```{r}
s[c(5, 7, 13)]
```

Можно узнать, сколько значений равно 3:
```{r}
sum(s == 3)
```

Еще полезная штучка --- количество элементов в векторе:
```{r}
length(b)
```

### Сравнение чисел --- штука тонкая

Правда ли, что 0.4 + 0.1 равно 0.5?
```{r}
0.4 + 0.1 == 0.5
```

А правда ли, что 0.4 - 0.1 равно 0.3?
```{r}
0.4 - 0.1 == 0.3
```

Хм, что-то Марь Иванна в школе другое говорила... 

Почему так случилось? Компьютер хранит числа в памяти в двоичной системе счисления. В двоичной системе обычное число 0.1 будет записываться в виде бесконечной периодической дроби. Следовательно, без дополнительных ухищрений храниться в памяти абсолютно точно оно не может. Поэтому де-факто компьютер хранит в памяти округленную версию от 0.4, 0.1 и 0.3. В данном случае при вычитании ошибки округления не компенсируют друг друга.




