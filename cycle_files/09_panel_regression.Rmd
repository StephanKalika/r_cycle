---
title: "[Заметки по R](http://bdemeshev.github.io/r_cycle/): Работа с панельными данными"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output: html_document
lang: russian
---

В панельных данных по каждому объекту у нас есть данные по нескольким переменным, меняющимся во времени.

## Подготовка данных

Загружаем нужные пакеты:
```{r, message=FALSE}
library("knitr") # используем Rmarkdown
library("texreg") # вывод результатов регрессии в тех и html

library("tidyverse") # подключаем ggplot2 (графики), dplyr, tidyr, etc (манипуляции с данными)
library("plm") # работа с панельками
# install.packages("plm") # может быть нужно установить пакеты...
```

Берём встроенный в пакет `plm` набор данных `Grunfeld`
```{r}
data(Grunfeld)
head(Grunfeld)
```

Указываем R, какая переменная отвечает за $i$, какая --- за $t$.
```{r}
h <- pdata.frame(Grunfeld,
                 index = c("firm", "year"),
                 row.names = TRUE)
```

Посмотрим на кусок таблички:
```{r}
Grunfeld[12:16, 3:5]
h[12:16, 3:5]
```

Добавим лагированные инвестиции
```{r}
h$linv <- stats::lag(h$inv)
h[c(1:3, 21:23), ]
```

Тут есть опасный момент! В R куча пакетов определяют функцию `lag`. Нам нужна версия команды из пакета `stats`, которая берёт лаг отдельно для каждого объекта, а не просто сдвигает весь вектор значений на одно наблюдение. Например, `lag` из `dplyr` не сработает!

Иллюстрируем опасный момент:
```{r}
h_bad <- mutate(h, linv = dplyr::lag(inv))
h_bad[18:22, ] 
```

С какого-то перепугу на панелях плохо сработает и классический dplyr:
```{r}
h_bad_2 <- mutate(h, linv = stats::lag(inv))
head(h_bad_2)
```



## Оценка моделей

Оценим три модели:
```{r}
m.pooled <- plm(inv ~ capital + value, data = h, model = "pooling")
m.re <- plm(inv ~ capital + value, data = h, model = "random")
m.fe <- plm(inv ~ capital + value, data = h, model = "within")
```

Все три модели можно записать в виде:
\[
y_{it}=\alpha + x'_{it}\beta + z'_i \gamma + c_i + u_{it}
\]

Здесь $z_i$ --- вектор характеристик, не меняющихся во времени, а $c_i$ и $u_{it}$ --- случайные составляющие, $E(c_i)=0$, $E(u_{it})=0$.

В модели со случайными эффектами (Random Effects, RE) предполагается, что $E(c_i | z_i, X_i) = 0$. 

В модели с фиксированными эффектами (Fixed Effects, FE) допускается, что $E(c_i| X_i)$ зависит от $X_i$. Модель с фиксированными эффектами не позволяет оценить $\alpha$ и $\gamma$. 

В сквозной регресси (pooling) предполагается, что $c_i=0$. 

Посмотрим отчёт по модели со случайным эффектами:
```{r}
summary(m.re)
```

Все три модели рядом:
```{r, results = 'asis'}
htmlreg(list(m.pooled, m.re, m.fe), 
        custom.model.names = c("Pooling", "RE", "FE"))
```



На самом деле модель сквозной регрессии и модель с фиксированными эффектами оцениваются обычным МНК. Эти результаты можно воспроизвести без пакета `plm` своими руками:
```{r}
m.pooled.lm <- lm(inv ~ capital + value, data = h)
m.fe.lm <- lm(inv ~ capital + value + factor(firm), data = h)
```

Сравним коэффициенты:
```{r}
coefficients(m.pooled)
coefficients(m.pooled.lm)
```

Аналогично совпадут и коэффициенты в моделях с фиксированными эффектами.

## Сравнение моделей

Проведём три теста на сравнение моделей. 

* Фиксированные эффекты против сквозной регрессии. Обычный F-тест.
```{r}
pFtest(m.fe, m.pooled)
```

Здесь нулевая гипотеза о верной сквозной модели отвергается в пользу модели с фиксированными эффектами.

* Фиксированные эффекты против случайных эффектов. Тест Хаусмана.
```{r}
phtest(m.fe, m.re)
```

Здесь нулевая гипотеза о состоятельности коэффициентов в обеих моделях (FE и RE) отвергается в пользу гипотезы о том, что в RE модели коэффициенты несостоятельны.

Кстати, этот тест может дать отрицательное значение $\chi^2$ статистики, т.к. хи-квадрат распределение она имеет только асимптотическое и только при верной $H_0$. А если наблюдений мало, или если $H_a$ верна, то можно получить отрицательные числа. Можно по приколу заметить, что модуль статистики Хаусмана также асимптотически распределён по хи-квадрату.


* Случайные эффекты против сквозной регрессии. Тест Бройша-Пагана, является одним из тестов множителей Лагранжа.
```{r}
plmtest(m.re, type = "bp")
```

Здесь нулевая гипотеза о верности сквозной регресси, то есть о том, что $c_i$ тождественно равны $0$, отвергается.

## Типичные проблемы

* Оценки по методу FE невозможно получить оценки коэффициентов при регрессорах, не изменяющихся во времени. Здесь для глупого примера включим номер фирмы :) А R его благополучно выкинет как неидентифицируемый.

```{r}
m_fe_bad <- plm(inv ~ capital + firm, data = h, model = "within")
summary(m_fe_bad)
```

<!--
* Оценки по методу RE невозможно получить, если число переменных больше количества фирм.

```{r}
small_data <- filter(h, firm %in% c(1, 2))
m_re_bad <- plm(inv ~ capital + value + I(value^2), data = h, model = "random")
summary(m_re_bad)
```

Бредятина какая-то. Но я помню, мы что-то мутили давным-давно и RE отказывался считаться.
-->



* При оценке по методу RE может получаться отрицательная оценка дисперсиии

```{r}
m_re_negative <- plm(inv ~ capital + value + linv, data = h, model = "random")
summary(m_re_negative)
```


Скорее всего это говорит о том, что имеющиеся данные плохо описываются моделью RE. Вероятнее всего в данных другая структура корреляции ошибок. Например, там присутствует автокорреляция первого порядка...


Почиташки:

* Виньетка [пакета `plm`](https://cran.r-project.org/web/packages/plm/vignettes/plm.pdf)
* Kurt Schmidtheiny, [Краткий курс по FE/RE/pooling](http://schmidheiny.name/teaching/panel.pdf)







