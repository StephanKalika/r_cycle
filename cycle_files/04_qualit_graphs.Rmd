# Анализ качественных переменных в R

Скажем knitr'у, что надо кэшировать куски для ускорения работы...
```{r}
library("knitr")
# opts_chunk$set(cache=TRUE)
```


Загрузим данные по стоимости квартир в Москве. Проверим, что они загрузились...
```{r}
h <- read.table("~/em301/datasets/flats_moscow.txt",header=TRUE)
str(h)
```


Загрузим пакет ggplot2 и установим чёрно-белую тему для всех последующих графиков
```{r}
library("reshape2")
library("ggplot2")

# theme_set(theme_gray())
theme_set(theme_bw())
```

Оценим logit модель, полином 5-ой степени, $P(y_i=1)=F(\beta_1+\beta_2 x_i+\ldots+\beta_6 x_i^5)$
```{r}
model <- glm(brick~poly(price,5),data=h,family=binomial)
summary(model)
```


Строим графики...
```{r}
ggplot(data=h,aes(x=price,y=brick))+
  geom_point(position=position_jitter(height=0.05),alpha=0.2)+
  stat_smooth(method="glm",family=binomial,formula=y~poly(x,4))
```

Две гистограммки
```{r}
ggplot(data=h,aes(x=price,fill=factor(brick)))+
  geom_density(alpha=0.5)
```

Виолончельки
```{r}
ggplot(data=h,aes(y=price,x=factor(brick)))+
  geom_violin()
```

Прогнозируем вероятности по нашей модели. Сравниваем их с настоящими $y_i$
```{r}
h$prob.brick<-fitted(model)
head(h[c("brick","prob.brick")])
```

Создаём функцию, которая по порогу считает количество [true positive, true negative и т.д.](http://en.wikipedia.org/wiki/Sensitivity_and_specificity)
```{r}
tfnp <- function(cut=0.5,y.true,prob) {
  y.pred <- (prob>cut)
  tp <- sum((y.true==1) & (y.pred==1))
  tn <- sum((y.true==0) & (y.pred==0))
  fp <- sum((y.true==0) & (y.pred==1))
  fn <- sum((y.true==1) & (y.pred==0))
  return(c(tp,tn,fp,fn))
}
tfnp(0.5,h$brick,h$prob.brick) # проверяем
```

Для разных порогов считаем специфичность и чувствительность
```{r}
t <- data.frame(cuts = seq(0,1,len=33),tp=0,tn=0,fp=0,fn=0)

for (i in 1:nrow(t)) {
  t[i,2:5] <- tfnp(t$cuts[i],h$brick,h$prob.brick)
}

t$spec <- t$tn/(t$tn+t$fp)
t$sens <- t$tp/(t$tp+t$fn)
t$correct <- (t$tp+t$tn)/(t$tp+t$tn+t$fn+t$fp)

head(t)
```

Зависимость специфичности от порога
```{r}
matplot(t$cuts,cbind(t$spec,t$sens,t$correct),type="l")

molten.t <- melt(t,id.vars="cuts",measure.vars=c("spec","sens","correct"))
ggplot(data=molten.t,aes(x=cuts,y=value,color=variable))+geom_line()
```

[Кривая ROC](http://en.wikipedia.org/wiki/Receiver_operating_characteristic)
```{r}
ggplot(data=t,aes(x=1-spec,y=sens))+geom_line()
```

Еще один график симпатяшка для качественных переменных
```{r}
library(vcd)
mosaic(data=h,~brick+walk+floor,shade=TRUE)
```

Остальные заметочки, [https://github.com/bdemeshev/em301/wiki/r_cycle](https://github.com/bdemeshev/em301/wiki/r_cycle)



