---
title: "[Заметки по R](http://bdemeshev.github.io/r_cycle/): Преобразования данных"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output: html_document
lang: russian
---

> Студенты думают, что `.csv` файлы как булки на деревьях растут!

Новички даже не предполагают, сколько времени занимает предварительная обработка данных! Удаление явно ошибочных значений, приведение к нужному формату, слияние данных из нескольких источников и прочие "мелочи".


Загружаем нужные библиотеки:
```{r, message=FALSE, warning=FALSE}
library("knitr")

library("dplyr") # стратегия Разделяй - Властвуй - Соединяй
library("reshape2") # melt - cast
library("ggplot2") # графики
```

## Создание выборок ...



## Разделяй и властвуй! Затем соединяй!

Многие преобразования могут быть описаны с помощью принципа 
"Разделяй и властвуй! Затем соединяй!":

  * разделяем большую табличку на много маленьких;
  
  * на каждой маленькой табличке делаем простые вычисления;
  
  * соединяем результат в одну большую табличку.

Загрузим данные по стоимости квартир в Москве:
```{r} 
filename <- "../datasets/flats_moscow.txt"
flats <- read.table(filename, header = TRUE)
```


Пример. Подсчёт описательных статистик внутри групп

Мы разбиваем большую таблицу на маленькие таблички по переменным `code` (географический район квартиры) и `brick` (кирпичность). По каждой маленькой табличке считаем число наблюдений и среднюю цену квартиры. Затем сводим в итоговую таблицу:
```{r}
flats_summ <- flats %>% group_by(code, brick) %>%
  summarize(n = n(), mean = mean(price))

head(flats_summ)
```

Пример. Корректировка наблюдения на групповое среднее. 

Из цены каждой квартиры будет вычтена средняя цена по квартирам данного района и данной кирпичности.
```{r}
flats_new <- flats %>% group_by(code, brick) %>%
  mutate(delta = price - mean(price))

head(flats_new)
```

Итого:

* команда `mutate` в финальной табличке создаёт столько строк, сколько было в изначальной табличке;

* команда `summarize` в финальной табличке создаёт столько строк, на сколько мелких табличек разрезали изначальную. 

* для подсчета числа наблюдений бывает полезна функция `n()`. Также её можно заменить на `length()` и указать внутри любую переменную.

## Отбор самых-самых наблюдений


## Длинная и широкая

> Теорема о крокодиле. Крокодил более широкий чем длинный.
>
> Доказательство. 
>
> Шаг 1. Крокодил более широкий, чем зеленый. Зеленый он только снаружи, а широкий он и снаружи и внутри.
>
> Шаг 2. Крокодил более зеленый, чем длинный. Зеленый он и в длину, и в ширину, а длинный - только в длину.
>
> Шаг 3. Отношение "больше" транзитивно :)
>
> Упражнение. Докажите, что крокодил более длинный, чем широкий.
>
> Упражнение. Докажите, что крокодилов не существует.

### Таблицы данных бывают "широкие" и "длинные".

Пример "широкой" таблицы:

```{r}
tab_wide <- smiths

head(tab_wide)
```


Пример "длинной" таблицы:

```{r}
names(airquality) <- tolower(names(airquality))
tab_long <- melt(airquality, id = c("month", "day"), na.rm = TRUE)

head(tab_long)
```


Данные удобнее обрабатывать в "длинном" формате. В "длинном" формате при получении новых наблюдений не нужно добавлять столбцы в `data.frame`. "Широкий" формат изредка бывает удобен для представления результатов. Или клиент так хочет.

Чтобы табличка растаяла из "широкого" формата и стекла вниз в "длинный" её можно растопить командой `melt` из пакета `reshape`:


```{r}
tab_long2 <- melt(tab_wide, id = "subject")

head(tab_long2)
```

Обратное действие выполняется командой `dcast`:


```{r}
tab_wide2 <- dcast(tab_long, day + month ~ variable)
head(tab_wide2)
```

## Слияние данных из разных источников

```{r}
# merge
```


## Векторизация функций

Если операция, которую нужно выполнить очень сложная, то можно сделать её в три шага:

* написать функцию, которая делает то, что нам нужно, с одним объектом;

* векторизовать функцию;

* применить функцию к большой табличке.




Этот подход, конечно, можно комбинировать с использованием стратегии Разделяй-Властвуй-Соединяй.


