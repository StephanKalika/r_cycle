---
title: "[Заметки по R](http://bdemeshev.github.io/r_cycle/): Преобразования данных"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output: html_document
lang: russian
---


!неплохо бы обновить до dplyr-reshape2

Новички даже не предполагают, сколько времени занимает предварительная обработка данных! Удаление явно ошибочных значений, приведение к нужному формату, слияние данных из нескольких источников и прочие "мелочи".


Загружаем нужные библиотеки:
```{r, message=FALSE, warning=FALSE}
library("knitr")
#opts_chunk$set(cache=TRUE) # кэшируем куски Rmd файла для скоростной компиляции после

library("plyr") # ddply
library("reshape") # melt - cast
library("ggplot2") # графики
```

## Создание выборок (нужно ли?)



## Разделяй и властвуй! Затем соединяй!

Многие преобразования могут быть описаны с помощью принципа 
"Разделяй и властвуй! Затем соединяй!":

  * разделяем большую табличку на много маленьких;
  
  * на каждой маленькой табличке делаем простые вычисления;
  
  * соединяем результат в одну большую табличку.

Загрузим данные по стоимости квартир в Москве:
```{r} 
filename <- "../datasets/flats_moscow.txt"
flats <- read.table(filename, header = TRUE)
```


Пример. Подсчёт описательных статистик внутри групп

Мы разбиваем большую таблицу на маленькие таблички по переменным `code` (географический район квартиры) и `brick` (кирпичность). По каждой маленькой табличке считаем число наблюдений и среднюю цену квартиры. Затем сводим в итоговую таблицу:
```{r}
flats.summ <- ddply(flats, ~ code + brick, summarize,
      n = length(price), mean = mean(price))

head(flats.summ)
```

Пример. Корректировка наблюдения на групповое среднее. 

Из цены каждой квартиры будет вычтена средняя цена по квартирам данного района и данной кирпичности.
```{r}
flats.new <- ddply(flats, ~ code + brick, transform,
            delta = price - mean(price))

head(flats.new)
```

Итого:

* опция `transform` в финальной табличке создаёт столько строк, сколько было в изначальной табличке;

* опция `summarize` в финальной табличке создаёт столько строк, на сколько мелких табличек разрезали изначальную. 

Из опыта. Для подсчета числа наблюдений бывает полезна функция `nrow()`. Функция `nrow()` работает только без имени переменной и без `summarize`.


## Длинная и широкая

### Теорема. Крокодил более широкий чем длинный.

Доказательство. 

Шаг 1. Крокодил более широкий, чем зеленый. Зеленый он только снаружи, а широкий он и снаружи и внутри.

Шаг 2. Крокодил более зеленый, чем длинный. Зеленый он и в длину, и в ширину, а длинный - только в длину.

Шаг 3. Отношение "больше" транзитивно :)


### Таблицы данных бывают "широкие" и "длинные".

Пример "широкой" таблицы:

```{r}
tab.wide <- smiths

head(tab.wide)
```


Пример "длинной" таблицы:

```{r}
names(airquality) <- tolower(names(airquality))
tab.long <- melt(airquality, id = c("month", "day"), na.rm = TRUE)

head(tab.long)
```


Данные удобнее обрабатывать в "длинном" формате. В "длинном" формате при получении новых наблюдений не нужно добавлять столбцы в data.frame. "Широкий" формат изредка бывает удобен для представления результатов. Или клиент так хочет.

Чтобы табличка растаяла из "широкого" формата и стекла вниз в "длинный" её можно растопить командой `melt` из пакета `reshape`:


```{r}
tab.long2 <- melt(tab.wide, id = "subject")

head(tab.long2)
```

Обратное действие выполняется командой `cast`:


```{r}
tab.wide2 <- cast(tab.long, day + month ~ variable, mean)

head(tab.wide2)
```

## Слияние данных из разных источников

```{r}
# merge
```


## Векторизация функций

Если операция, которую нужно выполнить очень сложная, то можно сделать её в три шага:

* написать функцию, которая делает то, что нам нужно, с одним объектом;

* векторизовать функцию;

* применить функцию к большой табличке.




Этот подход, конечно, можно комбинировать с использованием функции `ddply`.


