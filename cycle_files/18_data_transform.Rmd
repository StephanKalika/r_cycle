---
title: "[Заметки по R](http://bdemeshev.github.io/r_cycle/): Преобразования данных"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output: html_document
lang: russian
---


!неплохо бы обновить до dplyr-reshape2

Новички даже не предполагают, сколько времени занимает предварительная обработка данных! Удаление явно ошибочных значений, приведение к нужному формату, слияние данных из нескольких источников и прочие "мелочи".


Загружаем нужные библиотеки:
```{r, message=FALSE}
library("knitr")
#opts_chunk$set(cache=TRUE) # кэшируем куски Rmd файла для скоростной компиляции после

library("plyr") # ddply
library("reshape") # melt - cast
library("ggplot2") # графики
```

## Создание выборок (нужно ли?)



## Разделяй и властвуй! Затем соединяй!

Многие преобразования могут быть описаны с помощью принципа 
"Разделяй и властвуй! Затем соединяй!":
  * Разделяем большую табличку на много маленьких
  * На каждой маленькой табличке делаем простые вычисления
  * Соединяем результат в одну большую табличку

Загрузим данные по стоимости квартир в Москве:
```{r}
file <- "~/Documents/em301/datasets/flats_moscow.txt"
h <- read.table(file,header=TRUE)
```


Пример. Подсчёт описательных статистик внутри групп

Мы разбиваем большую таблицу на маленькие таблички по переменным `code` (географический район квартиры) и `brick` (кирпичность). По каждой маленькой табличке считаем число наблюдений и среднюю цену квартиры. Затем сводим в итоговую таблицу:
```{r}
h.summ <-ddply(h,~code+brick,summarize,
      n=length(price),mean=mean(price))
head(h.summ)
```

Пример. Корректировка наблюдения на групповое среднее. Из цены каждой квартиры будет вычтена средняя цена по квартирам данного района и данной кирпичности.
```{r}
h.new <- ddply(h,~code+brick,transform,
            delta=price-mean(price))
head(h.new)
```

Итого:
* опция `transform` в финальной табличке создаёт столько строк, сколько было в изначальной табличке
* опция `summarize` в финальной табличке создаёт столько строк, на сколько мелких табличек разрезали изначальную 

Из опыта. Для подсчета числа наблюдений бывает полезна функция `nrow()`. Функция `nrow()` работает только без имени переменной и без `summarize`.


## Длинная и широкая

### Теорема. Крокодил более широкий чем длинный.

Доказательство. 

Шаг 1. Крокодил более широкий, чем зеленый. Зеленый он только снаружи, а широкий он и снаружи и внутри.

Шаг 2. Крокодил более зеленый, чем длинный. Зеленый он и в длину, и в ширину, а длинный - только в длину.

Шаг 3. Отношение "больше" транзитивно :)


### Таблицы данных бывают "широкие" и "длинные".

Пример "широкой" таблицы

```{r}
tab.wide <- smiths
head(tab.wide)
```


Пример "длинной" таблицы

```{r}
names(airquality) <- tolower(names(airquality))
tab.long <- melt(airquality, id=c("month", "day"), na.rm=TRUE)

head(tab.long)
```


Данные удобнее обрабатывать в "длинном" формате. В "длинном" формате при получении новых наблюдений не нужно добавлять столбцы в data.frame. "Широкий" формат изредка бывает удобен для представления результатов. Или клиент так хочет.

Чтобы табличка растаяла из "широкого" формата и стекла вниз в "длинный" её можно растопить командой `melt` из пакета `reshape`.


```{r}
tab.long2 <- melt(tab.wide, id="subject")
head(tab.long2)
```

Обратное действие выполняется командой `cast`.


```{r}
tab.wide2 <- cast(tab.long, day + month ~ variable, mean)
head(tab.wide2)
```

## Слияние данных из разных источников

```{r}
# merge
```


## Векторизация функций

Если операция, которую нужно выполнить очень сложная, то можно сделать её в три шага:
* Написать функцию, которая делает то, что нам нужно, с одним объектом
* Векторизовать функцию 
* Применить функцию к большой табличке




Этот подход, конечно, можно комбинировать с использованием функции `ddply`.


